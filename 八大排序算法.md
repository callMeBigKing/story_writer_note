---
title: 八大排序算法
tags: 新建,模板,小书匠
grammar_cjkRuby: true
---
### 选择排序
第i轮找到后面最小的元素放在第i个位置上面
``` c++
void selectsort(int a[],int n)
{
	for(int i=0;i<n-1;i++)
	{
	 	int ci=i;
		for(int j=i+1;j<n;j++)
		{
			if (a[ci]>a[j])ci=j
			
		}
		if (ci!=i)swap(a[ci],a[i])
	}
}
```
### 冒泡排序
相邻元素比较，把最大的移到最后面去

``` c++
for(int i=0;i<n-1;i++)
{
	for(int j=i;j<n-i-1;j++)
	{
		if (a[j]>a[j+1])swap(a[j],a[j+1])
	}
}
```
### 直接插入排序

直接插入排序基本思想是每一步将一个待排序的记录，插入到前面已经排好序的有序序列中去，直到插完所有元素为止。基于一种递归的思想

``` c++
for(int i=1;i<n;i++)
{//前面i个已经排好序了
	int j=i;
	while(j>0&&a[j]<a[j-1])
	{
		swap(arr,j,j-1);
		j--;
	}
}
```
### 快速排序
[参考博客][1]
思想：对于每一个数，把比他小的放在左边大的放在右边，思想就是基准数，
先从右往左找一个小于基准数的数，再从左往右找一个大于基准数的数，然后交换这两个数
``` c++
int a[]={3,4,2,1,5,7,8}
void quicksort(int left,int right)
{
	int i,j,t,temp;
	if (left>rigth)return;
	norm=a[left]  //基准数 
	i,j=lef,rigtht;
	while (i!=j)
	{
		//先从右边再从左边
		while(a[j]>=temp&&i<j)j--;
		while(a[i]=<temp&&i<j)i++;
		if (i<j)swap(a,i,j);
		
	}
	swap(a,left,i);
	quicksort(left,i-1);
	quicksort(i+1,rigth);
}
```
### 归并排序
[参考博客][2]
归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。
递归代码
[递归代码][3]
``` c++
int a[]={1,2,4,3,7,5,6};
sort(int a[],int left,int rigth,int temp )
{
	if (left<rigth){
		int mid =(left+right)/2
		sort(arr,left,mid,temp)
		sort(arr,mid,rigth,temp)
		merge(arr,left,mid ,rigth,temp)
	}
}

merge(int a[],int left,int mid ,int right){
	i=left
	j=mid+1
	int t=0
	while(i<=mid;j<=rigth){
		if(a[i]<=a[j])temp[t++]=a[i++];
		else temp[t++]=a[j++]
	}
	while(j<=rigth)temp[t++]=a[j++]
	while(i<=mid)temp[t++]=a[i++]
}
t=0
while(left<rigth)a[left++]=temp[t++]
```
### 希尔排序
希尔排序是一种改进的插入排序
[参考代码][4]

``` c++
sort()
for(int gap=n/2;gap>=1;gap/=2)
{
	for(int i=gap;i<n;i++)
	{
		int j=i;
		while(j-gap>0&&a[j]<a[j-gap])
			swap(arr,j,j-gap)
			j-=gap
	}
}
```
### 基数排序

### 堆排序


  [1]: http://developer.51cto.com/art/201403/430986.htm
  [2]: http://www.cnblogs.com/chengxiao/p/6194356.html
  [3]: http://www.cnblogs.com/chengxiao/p/6194356.html
  [4]: http://blog.csdn.net/hguisu/article/details/7776068